<#
    .SYNOPSIS
    Downloads and runs Yara (VirusTotal) scanner tool
    
    .DESCRIPTION
    Downloads and runs Yara (VirusTotal) scanner tool with latest FireEye Yara rules, 
    reports back in csv output if scanned files match the FireEye Yara rules,
    downloads and installs VC++ 2015-2019 if required.
    
    .Notes
    Author: Dan Phoaser
    
    Credit: Datto/seagull for inspiration,
    Credit: VirusTotal for Yara scanner tools
    Credit: FireEye for FireEye Red Team Explot Yara rule file
        
#>

#Requires -Version 4

Function Write-POpsLog {
    <# 
    .SYNOPSIS 
       Write to a log file and to console if desired
 
    .DESCRIPTION 
       Write to a log file and to console if desired.
       Can write to regular text file or in CMTrace format.
 
    .EXAMPLE 
        Try{
            Get-Process -Name DoesnotExist -ea stop
        }
        Catch{
            Write-POpsLog -Logfile "C:\output\logfile.log" -Message $_ -MessageType Error
            Throw
        }
 
       This will write a line to the c:\output\logfile.log with error object details,
       and will also write back the error to the host.

       You will need to add a throw in the catch block if you want to rethrow the error.
 
    .EXAMPLE
        Set this preference at the top of your script:
        $POpsLogFile = "c:\output\logfile.log"
        $POpsWriteHost = $true
        
        Write-POpsLog -Message "This is a verbose message." 

        This example will write a verbose entry into the log file and also write back to the host. 
        If the -WriteHost switch is not specified, it will then just follow the value $VerbosePreference,
        and write the verbose message back to the host only if $VerbosePreference is set to 'Continue'.

    .EXAMPLE
        Set this preference at the top of your script:
        $POpsLogFile = "c:\output\logfile.log"
        $POpsWriteHost = $false
        
        Write-POpsLog -Message "This is a verbose message." 

        This example will write a verbose entry into the log file but will not write back to the host.

    .EXAMPLE
        Function Test{
            [cmdletbinding()]
            Param()
            Write-POpsLog -Message "This is a verbose message" -MessageType Verbose
        }
        Test -Verbose

        This example shows how to use Write-POpsLog inside a function and then call the function with the -verbose switch.
        The Write-POpsLog function will then print the verbose message on the host.
    
    .Parameter LogFile
        If LogFile is not specified, will then save the log file to "$Env:windir\Temp\Write-POpsLog" 
        
        You can specify $Script:POpsLogFile = "C:\Logs\YourLogFile.log" at the top of your main script,
        to avoid having to specify the LogFile parameter every time you call the function.

    .Parameter WriteHost       
        You can specify $Script:POpsWriteHost = $true or $false at the top of your main script,
        to avoid having to specify the -WriteHost switch parameter every time you call the function.

    .NOTES
        Author: Dan Phoaser

   
#> 
    [CmdletBinding(SupportsShouldProcess = $false)] 
    Param(
        [parameter(Position = 0, Mandatory = $True)] 
        $Message,	
        
        [parameter(Mandatory = $false)]      
        [String]$LogFile = $Script:POpsLogFile,

        [parameter(Mandatory = $false)]
        [ValidateSet('Warning', 'Error', 'Verbose', 'Debug', 'Information', 'Output')] 
        [Alias('Type')]
        [String]$MessageType = 'Verbose',

        [parameter(Mandatory = $false)]
        [ValidateSet('Basic', 'CMTrace')] 
        [String]$LogFormat = 'Basic',

        #Write back to the console or just to the log file. 
        [parameter(Mandatory = $false)]
        [Alias('WriteBackToHost')]
        [switch]$WriteHost = $Script:POpsWriteHost
    )
    
    Try {

        If ($null -eq $WriteHost -or '' -eq $WriteHost -or $WriteHost -eq $false) {
            $WriteHost = $false
        }

        #Get preferences
        $CurWarningPref = $PSCmdlet.GetVariableValue('WarningPreference')
        $CurErrActPref = $PSCmdlet.GetVariableValue('ErrorActionPreference')
        $CurVbosPref = $PSCmdlet.GetVariableValue('VerbosePreference')
        $CurDbgPref = $PSCmdlet.GetVariableValue('DebugPreference')
        $CurInfoPref = $PSCmdlet.GetVariableValue('InformationPreference')

        #Get the info about the calling script, function etc
        $CallingInfo = (Get-PSCallStack)[1]
	
        #Set Source Information
        #$Source = (Get-PSCallStack)[1].Location
        $Source = "$($MyInvocation.ScriptName | Split-Path -Leaf -ErrorAction SilentlyContinue):$($MyInvocation.ScriptLineNumber)"
        $MessageType = $MessageType.ToUpper()

        #Set Component Information
        $Component = (Get-Process -Id $PID).ProcessName

        #Set PID Information
        $ProcessID = $PID

        #Obtain UTC offset 
        $UtcOffset = [timezone]::CurrentTimeZone.GetUtcOffset([datetime]::Now).TotalMinutes

        $CurTimeHostFormat = $(Get-Date -Format 'yyyy-MM-dd HH:mm:ss.fff')

        If ( $null -eq $LogFile -or $LogFile -eq '') {
            $LogDir = "$Env:windir\Temp\Write-POpsLog"
            $LogFile = $LogDir + '\Log_'
            If ( $null -eq $CallingInfo.Command -or $CallingInfo.Command -like '<*>') {
                $LogFile = ($LogFile + 'Console.log')
            }
            Else {
                $LogFile = ($LogFile + $($CallingInfo.Command) + '.log')
            }
        }
        $LogDir = Split-Path -Path $LogFile
        $LogPathExists = Test-Path -Path $LogDir

        If ( $LogPathExists -eq $false ) {
            $null = New-Item -Path $LogDir -Type Directory -Force -WhatIf:$false
        }
    
        $HostMessage = @"
$CurTimeHostFormat [$MessageType]: $Message
"@
        $CMTraceMessage = $Message

        Switch ($MessageType) {    
            'Warning' {
                $Severity = 2
                if ($WriteHost -eq $true) {
                    $WarningPreference = 'Continue'
                }
                Write-Warning -Message $HostMessage
                $WarningPreference = $CurWarningPref
            }
            'Error' {  
                $Severity = 3
                if ($null -ne $Message.Exception.Message) {
                    $ErrObj = [pscustomobject]@{
                        Time              = $CurTimeHostFormat
                        Category          = $Message.CategoryInfo.Category
                        Reason            = $Message.CategoryInfo.Reason
                        Activity          = $Message.CategoryInfo.Activity
                        TargetName        = $Message.CategoryInfo.TargetName
                        TargetMessageType = $Message.CategoryInfo.TargetMessageType
                        MyCommand         = $Message.InvocationInfo.MyCommand         
                        BoundParameters   = $Message.InvocationInfo.BoundParameters
                        UnboundArguments  = $Message.InvocationInfo.UnboundArguments
                        ScriptName        = $Message.InvocationInfo.ScriptName
                        ScriptLineNumber  = $Message.InvocationInfo.ScriptLineNumber
                        OffsetInLine      = $Message.InvocationInfo.OffsetInLine
                        InvocationName    = $Message.InvocationInfo.InvocationName
                        PSScriptRoot      = $Message.InvocationInfo.PSScriptRoot
                        PSCommandPath     = $Message.InvocationInfo.PSCommandPath
                        Thrown            = $Message.Exception.WasThrownFromThrowStatement
                        Message           = $Message.Exception.Message
                    }
                    $HostMessage = @"
$CurTimeHostFormat [$MessageType]: [$Source]: $Message `n$($ErrObj | Out-String)
"@ 
                    $CMTraceMessage = $Message.Exception.Message
                }
                Else {
                    $HostMessage = @"
$CurTimeHostFormat [$MessageType]: [$Source]: $Message
"@         
                }
                Write-Host $HostMessage -ForegroundColor Red -BackgroundColor Black
                break
            }
            'Verbose' {  
                $Severity = 4
                if ($WriteHost -eq $true) {
                    $VerbosePreference = 'Continue'
                }
                Write-Verbose -Message $($HostMessage)
                $VerbosePreference = $CurVbosPref   
                break                            
            }
            'Debug' {  
                $Severity = 5
                if ($WriteHost -eq $true) {
                    $DebugPreference = 'Continue'
                }
                Write-Debug -Message $($HostMessage)
                $DebugPreference = $CurDbgPref
                break          
            }      
            'Information' {  
                $Severity = 6
                if ($WriteHost -eq $true) {
                    $InformationPreference = 'Continue'
                }
                Write-Information -Message "$($HostMessage)"
                $InformationPreference = $CurInfoPref
                break
            }
            'Output' {
                $Severity = 6
                $HostMessage = @"
$CurTimeHostFormat [$MessageType]: $($Message | Out-String) 
"@ 
                $CMTraceMessage = $($Message | Format-List | Out-String)
                Write-Output -InputObject $Message
                break
            }
            Default {}
        }#EndSwitch

        If ($LogFormat -eq 'CMTrace') {
            $LogLine = @"
<![LOG[$($MessageType.ToUpper()): $CMTraceMessage]LOG]!>
<time="$(Get-Date -Format HH:mm:ss.fff)$($UtcOffset)" 
date="$(Get-Date -Format MM-dd-yyyy)" 
component="$Component" 
context="$([System.Security.Principal.WindowsIdentity]::GetCurrent().Name)" 
MessageType="$severity" 
thread="$processid" 
file="$source"> 
"@
            $LogLine = $LogLine.Replace("$([environment]::NewLine)", "")
        }
    
        Else {
            $LogLine = $HostMessage
        }
    
        Try {            
            $LogLine | Out-File -Append -Encoding utf8 -FilePath $LogFile -Force -ErrorAction Stop -WhatIf:$false
        }
        Catch {
            Write-Host ("Error saving log: [$($_.Exception.Message)]") -ForegroundColor Red -BackgroundColor Black
        }
    }

    Catch {
        Throw
    }

    Finally {
        # Always revert the preference variables 
        # back to original settings, even if Ctrl + C is pressed, or execution ends.
        $VerbosePreference = $CurVbosPref
        $WarningPreference = $CurWarningPref 
        $DebugPreference = $CurDbgPref
        $InformationPreference = $CurInfoPref
    }
    
}

Function Unzip {
    param(
        [string]$zipfile, 
        [string]$outpath
    )
    #Extract File powershell funtion
    Add-Type -AssemblyName System.IO.Compression.FileSystem
    Write-POpsLog -Message "Extracting [$($zipfile)] to [$($outpath)]"
    #$null = Remove-Item -Path $outpath -Recurse -Exclude $zipfile -Force -ErrorAction SilentlyContinue
    $null = [System.IO.Compression.ZipFile]::ExtractToDirectory($zipfile, $outpath)
}

Function Invoke-POpsDownload {
    <# 
    .SYNOPSIS 
       Downloads file with net
 
    .DESCRIPTION 
       Downloads file with net, creates destination directory if doesn't exist,
       "-SkipSsl" Skips certificate check which helps download issues with older versions of 
       net framework.
       Recommend to refrain use of switch -SkipSSL for security.

       "-ExpandArchive" extracts a zip file for you to the parent folder of the file path.
       "-Force" overwrites downloaded file if already exists, and if "-ExpandArchive" is specified will overwrite destination for expansion.

    .NOTES
       Author: Dan Phoaser
   
#> 
 
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [uri]$Url,

        [Parameter(Mandatory = $true)]
        [ValidateNotNullOrEmpty()]
        [Alias('Path')]
        [string]$FilePath,

        [Parameter(Mandatory = $false)]
        [Switch]$SkipSslCheck = $false,

        [Parameter(Mandatory = $false)]
        [switch]$ExpandArchive,

        [Parameter(Mandatory = $false)]
        [switch]$Force

    )
    Begin {
        # Credit to https://stackoverflow.com/a/38729034 for code to ignore ssl certificate errors
        if ( !( [System.Management.Automation.PSTypeName]'ServerCertificateValidationCallback'.Type ) -and $SkipSslCheck -eq $true) {
            $CertCallback = @"
using System.Net;
using System.Security.Cryptography.X509Certificates;
public class TrustAllCertsPolicy : ICertificatePolicy {
    public bool CheckValidationResult(
        ServicePoint srvPoint, X509Certificate certificate,
        WebRequest request, int certificateProblem) {
        return true;
    }
}
"@
            Try {
                Add-Type $CertCallback -ErrorAction Stop
                $AllProtocols = [System.Net.SecurityProtocolType]'Ssl3,Tls,Tls11,Tls12'
                [System.Net.ServicePointManager]::SecurityProtocol = $AllProtocols
                [System.Net.ServicePointManager]::CertificatePolicy = New-Object TrustAllCertsPolicy -ErrorAction Stop              
                Write-POpsLog "Skipping Certificate Check"
            }
            Catch {
                Write-POpsLog "Error encountered when attempting to add CertCallBack class type" -Type Error
                Write-POpsLog -Message $_ -Type Error
                Write-POpsLog "Attempting to download without Skip SSL" -Type Warning
            }
        }
    }
    Process {
        $FileExists = Test-Path -Path $FilePath
        If ($FileExists -eq $true -and $Force -eq $false) {
            Write-POpsLog "File [$($FilePath)] already exists and '-Force' parameter was not specified." -Type Warning
            # Break results in script terminating, 
            # return results in function ending and script resuming.
            return
        }

        $FolderPath = Split-Path -Path $FilePath -Parent
        if ( !(Test-Path -Path $FolderPath) ) {
            Try {
                Write-POpsLog "Creating new folder: [$($FolderPath)]"
                $null = New-Item -Path $FolderPath -Type Directory -ErrorAction Stop;
            }
            Catch {
                Write-POpsLog "Error creating folder: [$($FolderPath)]" -Type Error
                Write-POpsLog -Message $_ -Type Error
                Throw 
            }
        }

        Try {
            $DlObj = New-Object System.Net.WebClient -ErrorAction Stop
            Write-POpsLog "Downloading file from url [$($Url)]"
            $DlObj.DownloadFile($Url, $FilePath)
        }
        Catch {
            Write-POpsLog -Message "Error downloading file" -Type Error
            Write-POpsLog -Message $_ -Type Error
            Throw
        }
        $DlSuccess = Test-Path -Path $FilePath
        If ($DlSuccess -eq $true) {
            Write-POpsLog "File downloaded successfully to: [$($FilePath)]"
            $CmdletExists = [bool](Get-Command -Name Unblock-File -ErrorAction SilentlyContinue)
            If ($CmdletExists -eq $true) {
                Write-POpsLog "Unblocking file: [$($FilePath)]"          
                Unblock-File -Path $FilePath
            }
        }
        Else {
            Write-POpsLog -Message "Unknown error downloading file" -Type Error
            Throw "Unknown error downloading file"
        }

        If ($ExpandArchive -eq $true) {
            $CmdletExists = $null
            $CmdletExists = Get-Command -Name Expand-Archive -ErrorAction SilentlyContinue
            
            If ($FilePath -like "*.zip") {
                $DestPath = $FilePath -replace '.zip', ''
                
                If ($CmdletExists) {
                    Try {               
                        Write-POpsLog -Message "Expanding file [$($FilePath)] to [$($DestPath)]"
                        $null = Expand-Archive -Path $FilePath -DestinationPath $DestPath -Force:$Force -ErrorAction Stop
                    }
                    Catch {
                        Write-POpsLog -Message "Error expanding archive" -Type Error
                        Write-POpsLog -Message $_ -Type Error
                        Throw
                    }
                }
                Else {
                    Write-POpsLog -Message "[Expand-Archive] cmdlet not found. Trying alternate function" -Type Warning
                    $null = Unzip -zipfile $FilePath -outpath $DestPath
                }
            }
            Else {
                Write-POpsLog -Message "File extension not .zip, cannot expand archive." -Type Warning
            }            
        }
    }
}

Function Start-POpsAdvProcess {
<#
    .SYNOPSIS
    Similar to Start-Process but returns output stream, error stream, and exit code
    
    .DESCRIPTION
    Similar to Start-Process but returns output stream, error stream, and exit code.
    By default, Start-PopsAdvProcess is set to wait until execution completes.

    .Parameter TestNetwork
    Specify -TestNetwork to only run the process if it can ping 8.8.8.8.
    
    .Notes
    Author: Dan Phoaser
    
    Credit: Datto/seagull for inspiration,
    Credit: VirusTotal for Yara scanner tools
    Credit: FireEye for FireEye Red Team Explot Yara rule file
        
#>

    [CmdletBinding()]
    Param(
        [Parameter(Position = 0, Mandatory = $true)]
        [Alias('Path')]
        [string]$FilePath,

        [Parameter(Position = 1, Mandatory = $false)] 
        [string[]]$ArgumentList,

        [Parameter(Mandatory = $false)]
        [switch]$TestNetwork = $false
    )

    Try {
        If ($TestNetwork -eq $true) {
            $InternetUp = Test-NetConnection -InformationLevel Quiet -ComputerName '8.8.8.8'
            If ($InternetUp -eq $false) {
                Throw 'Ping failed for 8.8.8.8 - aborting install.'
            }
        }
    }
    Catch {
        Write-POpsLog -Message $_ -MessageType Error
        Throw
    }

    Try {
        $ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo -ErrorAction Stop
        $ProcessInfo.FileName = $FilePath
        $ProcessInfo.RedirectStandardError = $true
        $ProcessInfo.RedirectStandardOutput = $true
        $ProcessInfo.UseShellExecute = $false
        $ProcessInfo.WindowStyle = 'Hidden'
        $ProcessInfo.CreateNoWindow = $True
        If ($null -ne $ArgumentList) {
            $ProcessInfo.Arguments = $ArgumentList
        }

        $ProcessObj = New-Object System.Diagnostics.Process -ErrorAction Stop
        $ProcessObj.StartInfo = $ProcessInfo
        $ProcessObj.Start() | Out-Null
        $StdOut = $ProcessObj.StandardOutput.ReadToEnd()
        $StdErr = $ProcessObj.StandardError.ReadToEnd()

        $ObjProp = @{
            Name         = $ProcessObj.Name
            Id           = $ProcessObj.Id
            FilePath     = $FilePath
            ArgumentList = $ArgumentList
            ProcessName  = $ProcessObj.ProcessName
            StartTime    = $ProcessObj.StartTime
            ExitTime     = $ProcessObj.ExitTime
            ExitCode     = $ProcessObj.ExitCode
            Output       = $StdOut
            Error        = $StdErr
        }

        $OutputProcObj = New-Object PSObject -Property $ObjProp

    }
    Catch {
        Write-POpsLog -Message $_ -MessageType Error
        Throw
    }

    
    Write-Verbose 'Disposing process to clean up remaining process memory store.'
    $ProcessObj.Dispose()

    Write-Output $OutputProcObj
}

Function Get-POpsLocalApp {
    <#
        .SYNOPSIS
        gets list of local apps
    
        .DESCRIPTION
        gets list of local apps from registry
    
        .Notes
        Author: Dan Phoaser
        
    #>
    [CmdletBinding()]
    Param(
        [string[]]$ExcludePublisher = $null,
        [string[]]$IncludePublisher = $null,
        [string[]]$ExcludeDisplayName = $null,
        [string[]]$IncludeDisplayName = $null,
        [switch]$IncludeSystemComponent
    )
    $RegPath = @('HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*', 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\*')
    
    Write-Verbose 'Getting list of programs from registry'
    $Apps = ForEach ($Path in $RegPath) {
        Try {
            Get-ItemProperty -Path $Path -ErrorAction Stop | Select-Object DisplayName, Publisher, DisplayVersion, InstallDate, InstallLocation, UninstallString, QuietUninstallString, SystemComponent, NoRemove, NoRepair, PSChildName, PSPath, PSParentPath
        }
        Catch [System.Management.Automation.ItemNotFoundException] {
            Write-Warning "Registry path [$($Path)] not found."
            Write-Warning "$($_ | Out-String)"
        }
        Catch {
            Throw
        }
    }
    
    If ($null -ne $ExcludePublisher) {
        $RegExPattern = ( $ExcludePublisher | ForEach-Object { [regex]::Escape($_) } ) -join '|'
        $Apps = $Apps | Where-Object { $_.Publisher -notmatch $RegExPattern }
    }

    If ($null -ne $IncludePublisher) {
        $RegExPattern = ( $IncludePublisher | ForEach-Object { [regex]::Escape($_) } ) -join '|'
        $Apps = $Apps | Where-Object { $_.Publisher -match $RegExPattern }
    }
    
    If ($null -ne $ExcludeDisplayName) {
        $RegExPattern = ( $ExcludeDisplayName | ForEach-Object { [regex]::Escape($_) } ) -join '|'
        $Apps = $Apps | Where-Object { $_.DisplayName -notmatch $RegExPattern }
    }
    
    If ($null -ne $IncludeDisplayName) {
        $RegExPattern = ( $IncludeDisplayName | ForEach-Object { [regex]::Escape($_) } ) -join '|'
        $Apps = $Apps | Where-Object { $_.DisplayName -match $RegExPattern }
    }

    If ($IncludeSystemComponent -eq $true) {
        Write-Output $Apps
    }
    Else {
        Write-Output $Apps | Where-Object { $null -ne $_.DisplayName -and '' -ne $_.DisplayName -and $_.SystemComponent -ne 1 }
    }
        
}

Function Get-POpsAllFiles {
    <#
        .SYNOPSIS
        Gets all files that match specific file extensions across a drive using robocopy
    
        .DESCRIPTION
        Gets all files that match specific file extensions across a drive using robocopy,
        mostly a helper function for Invoke-POpsYaraScan to retrieve a list of files to scan.
        
        This was created because get-childitem can fail even if erroraction is set to silentlycontinue,
        the failure mostly occurs when it encounters junction points and hidden system files like pagefile.sys
    
        .Notes
        Author: Dan Phoaser
        
    #>

    [CmdletBinding()]
    Param (
        [Parameter(Mandatory = $true)]
        $DriveLetter,

        $FileExtensions = $null
    )

    If ($null -eq $FileExtensions) {
        $Argliststr = @"
"$DriveLetter" NULL /l /s /ndl /xx /nc /ns /njh /njs /fp /xjd
"@        
    }
    Else {
        $Argliststr = @"
$DriveLetter\ NULL $FileExtensions /l /s /ndl /xx /nc /ns /njh /njs /fp /xjd
"@        
    }

    $RcOutput = Start-POpsAdvProcess -FilePath "$Env:windir\System32\Robocopy.exe" -ArgumentList $Argliststr
    $DirtyFileList = ($RcOutput.Output.Trim() -split "`r`n")

    $CleanFileList = ForEach($item in $DirtyFileList) {
        $item.Trim()
    }

    Write-Output $CleanFileList
}

Function Install-POpsVCRedist {
<#
    .SYNOPSIS
    Installs Visual C++ Redistributable 2015-2019 bundle

    .DESCRIPTION
    Installs Visual C++ Redistributable 2015-2019 bundle x86 and x64 variants.
    By default, will try to download installer files from Microsoft first.
    Will not install if it detects 2015-2019 bundle is already installed.

    Will download file by default to:
    "$env:SystemDrive\RMM\Apps\" folder

    .Parameter DestinationFolder
    Specify destination folder if you want to download to a different folder instead of default.

    .Parameter VCx64Url
    Specify an alternate download url for VC++ 2015-2019 (x64) bundle as a fallback if it's unable to
    download from Microsoft.

    .Parameter VCx86Url
    Specify an alternate download url for VC++ 2015-2019 (x86) bundle as a fallback if it's unable to
    download from Microsoft.

    .Notes
    Author: Dan Phoaser
    
#>

    [CmdletBinding()]
    Param(
        [uri]$VCx64Url = $Script:POpsVCx64Url,
        [uri]$VCx86Url = $Script:POpsVCx86Url,
        [string]$DestinationFolder = $Script:DestinationFolder
    )

    [string]$SysArch = [intPtr]::Size * 8

    $VCx64UrlArray = @(
        'https://aka.ms/vs/16/release/vc_redist.x64.exe'
    )
    $VCx86UrlArray = @(
        'https://aka.ms/vs/16/release/vc_redist.x86.exe'
    )

    If ('' -ne $VCx64Url -and $null -ne $VCx64Url) {
        $VCx64UrlArray+=$VCx64Url
    }

    If ('' -ne $VCx86Url -and $null -ne $VCx86Url) {
        $VCx86UrlArray+=$VCx86Url
    }

    If ([string]::IsNullOrEmpty($DestinationFolder) -eq $false) {
        $DirExists = Test-Path -Path $DestinationFolder
        If ($DirExists -eq $false) {
            Try {
                $null = New-Item -Path $DestinationFolder -Type Directory -ErrorAction Stop
                $VCRedistExePathx64 = "$DestinationFolder\VC_redist_2015-2019_x64.exe"
                $VCRedistExePathx86 = "$DestinationFolder\VC_redist_2015-2019_x86.exe"               
            }
            Catch {
                Write-POpsLog -Message $_ -MessageType Error
                Throw
            }
        }
    }
    Else {
        $VCRedistExePathx64 = "$env:SystemDrive\RMM\Apps\VC_redist_2015-2019_x64.exe"
        $VCRedistExePathx86 = "$env:SystemDrive\RMM\Apps\VC_redist_2015-2019_x86.exe"
    }

    $AppNames = @(
        'Microsoft Visual C++ 2015-2019 Redistributable (x64)',
        'Microsoft Visual C++ 2015-2019 Redistributable (x86)'
    )

    $InstallArgs = @"
/install /quiet /norestart
"@

    If ($SysArch -eq '64') {
        # Download VC++ 2015-2019 x64 bundle if not installed
        $IsAppInstalled = [bool](Get-POpsLocalApp -IncludeDisplayName $AppNames[0])
        If ($IsAppInstalled -eq $false) {    
            Try {
                Invoke-POpsDownload -Url $VCRedistUrlx64[0] -FilePath $VCRedistExePathx64 -ErrorAction Stop
            }
            Catch {
                Invoke-POpsDownload -Url $VCRedistUrlx64[1] -FilePath $VCRedistExePathx64 -ErrorAction Stop
            }
        
            Write-POpsLog "Installing [$($AppNames[0])]"
            Start-POpsAdvProcess -FilePath $VCRedistExePathx64 -ArgumentList $InstallArgs
        
            $IsAppInstalled = [bool](Get-POpsLocalApp -IncludeDisplayName $AppNames[0])
            If ($IsAppInstalled -eq $true) {
                Write-POpsLog "[$($AppNames[0])] successfully installed. Restart of script execution required."
            }
            Else {
                Write-POpsLog "[$($AppNames[0])] install failed" -MessageType Error
            }
        }

        Else {
            Write-POpsLog "[$($AppNames[0])] already installed." -MessageType Warning
        }
    }

    # Download VC++ 2015-2019 x86 bundle if not installed
    $IsAppInstalled = $null
    $IsAppInstalled = [bool](Get-POpsLocalApp -IncludeDisplayName $AppNames[1])
    If ($IsAppInstalled -eq $false) {
        Try {
            Invoke-POpsDownload -Url $VCRedistUrlx86[0] -FilePath $VCRedistExePathx86 -ErrorAction Stop
        }
        Catch {
            Invoke-POpsDownload -Url $VCRedistUrlx86[1] -FilePath $VCRedistExePathx86
        }

        Write-POpsLog "Installing [$($AppNames[1])]"
        Start-POpsAdvProcess -FilePath $VCRedistExePathx86 -ArgumentList $InstallArgs
    
        $IsAppInstalled = [bool](Get-POpsLocalApp -IncludeDisplayName $AppNames[1])
        If ($IsAppInstalled -eq $true) {
            Write-POpsLog "[$($AppNames[1])] successfully installed. Restart of script execution required."
        }
        Else {
            Write-POpsLog "[$($AppNames[1])] install failed" -MessageType Error
        }
    }
    Else {
        Write-POpsLog "[$($AppNames[1])] already installed." -MessageType Warning
    }
}

Function Invoke-POpsYaraScan {
    [CmdletBinding()]
    Param(
        [uri]$YaraExeX64Url,
        [uri]$YaraExeX86Url,
        [uri]$FireEyeRulesUrl = 'https://raw.githubusercontent.com/fireeye/red_team_tool_countermeasures/master/all-yara.yar',
        [string]$DestinationFolder = $Script:DestinationFolder,
        [int]$ScanLevel = 1,
        [int]$FileType = 1
    )
    
    [string]$SysArch = [intPtr]::Size * 8

    #region FireEye Scanner urls and paths
    
    $ExploitFound = $false

    If ([string]::IsNullOrEmpty($DestinationFolder) -eq $false) {
        $DestinationFolder = "$env:SystemDrive\RMM\FireEye_Red_Team_Scanner"
    }
       
    $YaraRulesPath = "$DestinationFolder\all-yara.yar"
    $YaraExePath = "$DestinationFolder\yara$($SysArch).exe"
    
    #endregion FireEye Scanner urls and paths

    # Check url parameters to ensure they are not empty
    If (
        $null -eq $YaraExeX64Url -or 
        '' -eq $YaraExeX64Url -and 
        $null -eq $YaraExeX86Url -or 
        '' -eq $YaraExeX86Url
        ) 
    {
        Write-POpsLog -Message "Error: You must specify a value for [YaraExeX64Url] or [YaraExeX86Url]" -MessageType Error
        Throw "Error: You must specify a value for [YaraExeX64Url] or [YaraExeX86Url]"
        Exit 1
    }

    Write-POpsLog -Message "OS Bitness architecture is [$($SysArch)]"
    Write-POpsLog -Message "Getting latest FireEye Yara rules"
    Try {
        Invoke-POpsDownload -Url $FireEyeRulesUrl -FilePath $YaraRulesPath -Force -ErrorAction Stop
    }
    Catch {
        Write-POpsLog -Message $_ -MessageType Error
        Throw
    }
    
    $ExeExists = Test-Path -Path $YaraExePath
    If ($ExeExists -eq $false) {
        Write-POpsLog -Message "Downloading Yara scanner"
        Try {
            If ($SysArch -eq '64') {
                Invoke-POpsDownload -Url $YaraExeX64Url -FilePath $YaraExePath -ErrorAction Stop
            }
            Else {
                Invoke-POpsDownload -Url $YaraExeX86Url -FilePath $YaraExePath -ErrorAction Stop
            }
        }
        Catch {
            Write-POpsLog -Message $_ -MessageType Error
            Throw
        }
    }
    
    $InScanLevel = [int]$InScanLevel
    Write-POpsLog -Message "Scan scope set to [$($InScanLevel)]"
    
    Write-POpsLog -Message "Initializing Yara test run to ensure it can run on this system"
    $YaraArgList = '-v'
    
    $YaraOutput = Start-POpsAdvProcess -FilePath $YaraExePath -ArgumentList $YaraArgList
    Write-POpsLog -Message $YaraOutput -MessageType Output
    Try {
        If ($YaraOutput.ExitCode -ne 0) {
            Throw "Yara was not able to run on this device, ExitCode [$($YaraOutput.ExitCode)], Error: [$($YaraOutput.Error)]"
        }
    }
    Catch {
        Write-POpsLog -Message $_ -MessageType Error
        Write-POpsLog -Message $YaraOutput -MessageType Output
        Install-VCRedist
        Throw
        Exit 1
    }
    
    Switch([int]$FileType) {
        1 {
            $FileExt = '*.exe'
            break
        }
    
        2 {
            $FileExt = '*.exe *.dll'
            break
        }

        Default {
            $FileExt = '*.exe'
        }
    }
    
    Switch ([int]$ScanLevel) {
        1 {
            Write-POpsLog -Message "Retrieving list of currently running processes"
            $Proc = Get-Process
            Try { 
                $ScanList = $Proc | Select-Object -Property Path -Unique -ExpandProperty Path -ErrorAction Stop
            }
            Catch {
                $ScanList = $Proc | Select-Object -Property Path -Unique
            }
            Break
        }
    
        2 {
            Write-POpsLog -Message "Retrieving file types [$($FileExt)] present on home drive [$($Env:HOMEDRIVE)]"
            $ScanList = Get-POpsAllFiles -DriveLetter $Env:HOMEDRIVE -FileExtensions $FileExt
            Break
        }
    
        3 {
            Write-POpsLog -Message "Retrieving file types [$($FileExt)] present on fixed drives"
            $DriveList = Get-WmiObject -Class Win32_logicaldisk | Where-Object { $_.DriveType -eq 3 -and $null -ne $_.FreeSpace -and '' -ne $_.FreeSpace }
            $ScanList = ForEach ($Drive in $DriveList.DeviceID) {
                Write-POpsLog -Message "Retrieving file types [$($FileExt)] present on drive [$($Drive)]"
                Get-POpsAllFiles -DriveLetter $Drive -FileExtensions $FileExt
            }
            Break
        }
    
        4 {
            Write-POpsLog -Message "Retrieving file types [$($FileExt -join ",")] present on fixed, removable, and CD drives"
            $DriveList = Get-WmiObject -Class Win32_logicaldisk | Where-Object {
                    $_.DriveType -eq 2 -or 
                    $_.DriveType -eq 3 -or 
                    $_.DriveType -eq 5 -and 
                    $null -ne $_.FreeSpace -and 
                    '' -ne $_.FreeSpace }
            $ScanList = ForEach ($Drive in $DriveList.DeviceID) {
                Write-POpsLog -Message "Retrieving file types [$($FileExt)] present on drive [$($Drive)]"
                Get-POpsAllFiles -DriveLetter $Drive -FileExtensions $FileExt
            }
            Break
        }
    
        Default {
            Write-POpsLog -Message "Retrieving list of currently running processes"
            $Proc = Get-Process
            Try { 
                $ScanList = $Proc | Select-Object -Property Path -Unique -ExpandProperty Path -ErrorAction Stop
            }
            Catch {
                $ScanList = $Proc | Select-Object -Property Path -Unique
            }
        }
    }
    
    If (!($ScanList) ) {
        Try {
            Throw "Failed to get list of exe files to scan."
        }
        Catch {
            Write-POpsLog -Message $_ -MessageType Error
            Throw
            Exit 1
        }
    }
    
    Write-POpsLog -Message "Scanning total of [$($ScanList.Count)] files"
    $ScanCount = 0
    $YaraOutput = ForEach ($File in $ScanList) {
        $ScanResult = $null
        $ScanCount++
        $YaraArgList = @"
"$YaraRulesPath" "$File" -s
"@
        # Disabled log to prevent large log files,
        # as scanned files are outputted to csv log anyways
        #Write-POpsLog -Message "Scanning file [$($File)]"
        Write-Host "Scanning file $ScanCount / $($ScanList.Count): [$($File)]"
        
        $ScanResult = Start-POpsAdvProcess -FilePath $YaraExePath -ArgumentList $YaraArgList | 
            Select-Object @{n = 'ScannedFile'; e = { $File } },
                @{n='ExploitFound'; e = {If[string]::IsNullOrEmpty($_.Output) -eq $false {$true}Else{$False} }},
                ExitCode, Output, Error, StartTime, ExitTime
        
        If ($ScanResult.ExploitFound -eq $true) {
            Write-POpsLog -Message "Exploit match on file: [$($File)]" -MessageType Warning
        }

        Write-Output $ScanResult
    }
    $ExploitObj = $YaraOutput | Where-Object { $_.ExploitFound -eq $true }
    
    $Now = $(Get-Date -Format 'yyyyMMdd-HHmmss')
    $LogFolder = "$DestinationFolder\Logs"
    $YaraLogFile = "$LogFolder\$($env:COMPUTERNAME)_$($Now)_yara_scan.csv"
    $null = New-Item -Path $LogFolder -Type Directory -ErrorAction SilentlyContinue
    
    If ( $ExploitObj  ) {
        Write-POpsLog -Message "FireEye Red Team exploits found! Review yara log for details" -MessageType Warning
        $ExploitFound = $true
    }
    Else {
        Write-POpsLog -Message "No FireEye Red Team exploits found. Review yara log for scan details"
    }
    
    $YaraOutput | Export-Csv -Path $YaraLogFile -NoTypeInformation
    Write-POpsLog -Message "Yara scan log exported to: [$($YaraLogFile)]"

    Write-Output $ExploitFound,$LogFolder
}

########################################################

# Set this script up as a RMM service monitor with InScanLevel set to 1
# You can always set up a RMM task schedule to run more intensive scan of InScanLevel 2, 3, or 4

############## RMM INPUT ##############

# $InScanLevel = 1 (1 | 2 | 3 | 4)
#    Default should be 1 if using as a RMM monitor.
#    If you would like to scan entire drive, then run it as an RMM task instead of a monitor to prevent execution timeouts.
#    1: Scans currently running processes - takes about 10 minutes
#    2: Scans home drive 
#    3: Scans all fixed drives
#    4: Scans all accessible drives

# $InFileType = 1 (1 | 2)
#    Default is 1.
#    1: Scan only exe files - default if $InScanLevel = 1
#    2: Scan exe and dll files

############## RMM OUTPUT ##############

# $OutExploitFound : FALSE is healthy, TRUE is failed
# $OutLogFolder : This is folder for the Yara scan csvs and is different from the script log, 
# see below to change script log file by changing $Script:POpsLogFile variable

############## CHANGE THE SCRIPT VARIABLES ##############

# Change to $false if you don't want output to the console, and only want output to the script log.
$Script:POpsWriteHost = $true

# Specify log file for script logging
# Yara log file is output separately as a csv to the $DestinationFolder.
$Script:POpsLogFile = "$env:SystemDrive\RMM\Logs\$($env:COMPUTERNAME)_FireEye Exploit Scan.log"

# Specify the fallback download urls for VC++ 2015-2019 x64 and x86 or set to $null 
# to only try downloading from Microsoft.
$Script:POpsVCx64Url = $null
$Script:POpsVCx86Url = $null

# Specify the destination folder for yara exe, vc++ exes, logs.
# yara exe will download to "$DestinationFolder\yara64.exe" or "$DestinationFolder\yara32.exe".
# vc++ will download to "$DestinationFolder\VC_redist_2015-2019_x64.exe", 
# or "$DestinationFolder\VC_redist_2015-2019_x86.exe".
# Yara log csv of scanned files is exported to "$DestinationFolder\Logs".
$Script:DestinationFolder = <CHANGEME>

############## CHANGE THE PARAMETER VALUES ##############

# Change the parameter values for Invoke-POpsYaraScan 
# and map the RMM input variables to the appropiate parameters.
$YaraScan = Invoke-POpsYaraScan -YaraExeX64Url <CHANGEME> -YaraExeX86Url <CHANGEME> -ScanLevel $InScanLevel -FileType $InFileType

# See RMM OUTPUT above for what this means
$OutExploitFound = $YaraScan[0]
$OutLogFolder = $YaraScan[1]